____________________________BIT MANIPULATION AND MASKING_______________________

Thruth Tables
AND
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
1 & 1 = 1
=========
OR
0 | 0 = 0
1 | 0 = 1
0 | 1 = 1
1 | 1 = 1
=========
LEFT_SHIFT (<<)
- Shifts binary digits to the left by n spaces and puts 0's on the right
- Each shift is equivalent to multiplying by 2 unless overflow occurs. Moreover,
that overflow can also include most significant byte changing from 0 to 1 (signed)

RIGHT_SHIFT (>>)
- Shifts binary digits to the right by n spaces
- If value is unsigned we put 0's on the left







				++++++++++++++++++++EXAMPLE++++++++++++++++++++

0000 0011
0000 0011 - representation of 3

0	00101100	nothing shifted - 0
1	00010110	shifted 1 right - 0
2	00001011	shifted 2 right - 1
3	00000101	shifted 3 right - 1
4	00000010	shifted 4 right - 0
5	00000001	shifted 5 right - 1
6	00000000	shifted 6 right - 1
7	00000000	shifted 7 right - 0

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
/*
Assignment name  : inter
Expected files   : inter.c
Allowed functions: write
--------------------------------------------------------------------------------

Write a program that takes two strings and displays, without doubles, the
characters that appear in both strings, in the order they appear in the first
one.

The display will be followed by a \n.

If the number of arguments is not 2, the program displays \n.

Examples:

$>./inter "padinton" "paqefwtdjetyiytjneytjoeyjnejeyj" | cat -e
padinto$
$>./inter ddf6vewg64f gtwthgdwthdwfteewhrtag6h4ffdhsd | cat -e
df6ewg4$
$>./inter "rien" "cette phrase ne cache rien" | cat -e
rien$
$>./inter | cat -e
$
*/

#include <unistd.h>

int	main(int argc, char **argv)
{
	int	len;
	int	i;
	int	j;
	int	unique;
	int	allow;

	len = 0;
	i = 0;
	if (argc == 3)
	{
		while (argv[1][i])
		{
			unique = 1;
			j = 0;
			allow = 0;
			while (j < i)
			{
				if (argv[1][i] == argv[1][j])
					unique = 0;
				j++;
			}
			j = 0;
			while (argv[2][j])
			{
				if (argv[1][i] == argv[2][j])
					allow = 1;
				j++;
			}
			if (unique && allow)
				write(1, &argv[1][i], 1);
			i++;
		}
	}
	write(1, "\n", 1);
	return (0);
}



/*
Assignment name  : union
Expected files   : union.c
Allowed functions: write
--------------------------------------------------------------------------------

Write a program that takes two strings and displays, without doubles, the
characters that appear in either one of the strings.

The display will be in the order characters appear in the command line, and
will be followed by a \n.

If the number of arguments is not 2, the program displays \n.

Example:

$>./union zpadinton "paqefwtdjetyiytjneytjoeyjnejeyj" | cat -e
zpadintoqefwjy$
$>./union ddf6vewg64f gtwthgdwthdwfteewhrtag6h4ffdhsd | cat -e
  ./inter ddf6vewg64f gtwthgdwthdwfteewhrtag6h4ffdhsd | cat -e
df6vewg4thras$
$>./union "rien" "cette phrase ne cache rien" | cat -e
rienct phas$
$>./union | cat -e
$
$>
$>./union "rien" | cat -e
$
$>
*/

#include <unistd.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		i++;
	}
	return (i);
}

int	main(int argc, char **argv)
{
	int		i;
	int		len;
	int		j;
	int		unique;

	i = 0;
	len = 0;
	j = 0;
	if (argc == 3)
	{
		len = ft_strlen(argv[1]); // total length of concatenated string
		while (argv[2][i]) // strcat
		{
			argv[1][len] = argv[2][i];
			len++;
			i++;
		}
		len--;
		while (j <= len)
		{
			// current character weâ€™re checking:
			// argv[1][j]
			i = 0;
			unique = 1;
			while (i < j)
			{
				// Step 4: check all characters *before* j (current char)
				// if any of them equals the current character,
				// mark it as duplicate (unique = 0)
				if (argv[1][i] == argv[1][j])
					unique = 0;
				i++;
			}
			if (unique)
				write(1, &argv[1][j], 1);
			j++;
		}
	}
	write(1, "\n", 1);
	return (0);
}

/*
Assignment name  : last_word
Expected files   : last_word.c
Allowed functions: write
--------------------------------------------------------------------------------

Write a program that takes a string and displays its last word followed by a \n.

A word is a section of string delimited by spaces/tabs or by the start/end of
the string.

If the number of parameters is not 1, or there are no words, display a newline.

Example:

$> ./last_word "FOR PONY" | cat -e
PONY$
$> ./last_word "this        ...       is sparta, then again, maybe    not"
not$
$> ./last_word "   " | cat -e
$
$> ./last_word "a" "b" | cat -e
$
$> ./last_word "  lorem,ipsum  " | cat -e
lorem,ipsum$
$>
*/

#include <unistd.h>
#include <stdio.h>

int	main(int argc, char **argv)
{
	int	len;

	len = 0;
	if (argc == 2)
	{
		while (argv[1][len])
			len++;
		len--;
		while (argv[1][len] == ' ' || argv[1][len] == '\t')
			len--;
		while (!(argv[1][len] == ' ' || argv[1][len] == '\t'))
			len--;
		len++;
		while (argv[1][len] && !(argv[1][len] == ' ' || argv[1][len] == '\t'))
		{
			write(1, &argv[1][len], 1);
			len++;
		}
	}
	write(1, "\n", 1);
	return (0);
}

/*
Assignment name  : wdmatch
Expected files   : wdmatch.c
Allowed functions: write
--------------------------------------------------------------------------------

Write a program that takes two strings and checks whether it's possible to
write the first string with characters from the second string, while respecting
the order in which these characters appear in the second string.

If it's possible, the program displays the string, followed by a \n, otherwise
it simply displays a \n.

If the number of arguments is not 2, the program displays a \n.

Examples:

$>./wdmatch "faya" "fgvvfdxcacpolhyghbreda" | cat -e
faya$
$>./wdmatch "faya" "fgvvfdxcacpolhyghbred" | cat -e
$
$>./wdmatch "quarante deux" "qfqfsudf arzgsayns tsregfdgs sjytdekuoixq " | cat -e
quarante deux$
$>./wdmatch "error" rrerrrfiiljdfxjyuifrrvcoojh | cat -e
$
$>./wdmatch | cat -e
$
*/

#include <unistd.h>

size_t	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i++;
	return (i);
}

int	main(int argc, char **argv)
{
	int	i;
	int	j;
	int	allow;

	i = 0;
	j = 0;
	if (argc == 3)
	{
		while (argv[1][i])
		{
			allow = 0;
			while (argv[2][j])
			{
				if (argv[1][i] == argv[2][j])
				{
					allow = 1;
					break ;
				}
				j++;
			}
			i++;
		}
		if (allow)
			write(1, argv[1], ft_strlen(argv[1]));
	}
	write(1, "\n", 1);
	return (0);
}


Tomorrow morning before lesson need to figure out all bitwise manipulation. After
lesson, do all level 3.